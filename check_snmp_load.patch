--- nagios-snmp-plugins-1.2/Makefile.am	2009-09-15 10:34:29.671421737 +0300
+++ nagios-snmp-plugins-1.2-load/Makefile.am	2009-09-15 10:15:32.164033835 +0300
@@ -8,20 +8,23 @@
 # 
 ########################################################################
 
-bin_PROGRAMS = check_snmp_disk check_snmp_proc check_snmp_swap
+bin_PROGRAMS = check_snmp_disk check_snmp_proc check_snmp_swap check_snmp_load
 
 SNMP_OBJ = snmp_common.o
 
 check_snmp_disk_LDADD = $(SNMP_OBJ)
 check_snmp_proc_LDADD = $(SNMP_OBJ)
 check_snmp_swap_LDADD = $(SNMP_OBJ)
+check_snmp_load_LDADD = $(SNMP_OBJ)
 
 check_snmp_disk_DEPENDENCIES = $(SNMP_OBJ)
 check_snmp_proc_DEPENDENCIES = $(SNMP_OBJ)
 check_snmp_swap_DEPENDENCIES = $(SNMP_OBJ)
+check_snmp_load_DEPENDENCIES = $(SNMP_OBJ)
 
 snmp_common.o: snmp_common.c snmp_common.h
 
 check_snmp_disk.o: check_snmp_disk.c snmp_common.h
 check_snmp_proc.o: check_snmp_proc.c snmp_common.h
 check_snmp_swap.o: check_snmp_swap.c snmp_common.h
+check_snmp_load.o: check_snmp_load.c snmp_common.h
--- /dev/null	2006-03-28 14:00:37.000000000 +0300
+++ nagios-snmp-plugins-1.2-load/check_snmp_load.c	2009-09-15 10:31:06.203940494 +0300
@@ -0,0 +1,204 @@
+/*************************************************************************
+ *
+ * plugins for Nagios
+ *
+ * (C) 2002-2008
+ *   Henning P. Schmiedehausen
+ *   INTERMETA - Gesellschaft fuer Mehrwertdienste mbH
+ *   Hutweide 15
+ *   D-91054 Buckenhof
+ * (C) 2009
+ *   Elan Ruusam√§e, <glen@delfi.ee>
+ *
+ *************************************************************************
+ *
+ * Checks the load for a given host via snmp and the ucd snmp interface.
+ *
+ *************************************************************************
+ *
+ * Distributed under GPL.
+ *
+ * $Id$
+ *
+ */
+
+#include "snmp_common.h"
+
+#define RCS_VERSION "$Revision$ ($Date$)"
+
+#define LOAD_INDEX_MIB       ".1.3.6.1.4.1.2021.10.1.1"
+#define LOAD_ERRORFLAG_MIB   ".1.3.6.1.4.1.2021.10.1.100"
+#define LOAD_ERRORMSG_MIB    ".1.3.6.1.4.1.2021.10.1.101"
+
+static int report_load(void);
+
+int main (int argc, char *argv[])
+{
+  static struct option long_options[] = {
+    { "help",      no_argument,       0, 'h' },
+    { "version",   no_argument,       0, 'V' },
+    { "timeout",   required_argument, 0, 't' },
+    { "community", required_argument, 0, 'C' },
+    { "hostname",  required_argument, 0, 'H' },
+    { "verbose",   no_argument,       0, 'v' },
+    { 0, 0, 0, 0 },
+  };
+  int option_index = 0;
+  int c;
+
+  int ret = STATE_UNKNOWN;
+
+  bn = strdup(basename(argv[0]));
+  version = VERSION;
+
+#define OPTS "?hVvt:c:w:C:H:"
+  
+  while(1)
+  {
+    c = getopt_long(argc, argv, OPTS, long_options, &option_index);
+
+    if(c == -1 || c == EOF)
+      break;
+
+    switch(c)
+    {
+      case '?':
+      case 'h':
+        print_help();
+        exit(STATE_UNKNOWN);
+
+      case 'V':
+        print_version();
+        exit(STATE_UNKNOWN);
+
+
+      case 't':
+        if(!is_integer(optarg))
+        {
+          printf("%s: Timeout interval (%s)must be integer!\n",
+                 bn,
+                 optarg);
+          exit(STATE_UNKNOWN);
+        }
+        
+        timeout = atoi(optarg);
+        if(verbose)
+          printf("%s: Timeout set to %d\n", bn, timeout);
+        break;
+
+      case 'C':
+        community = strdup(optarg);
+
+        if(verbose)
+          printf("%s: Community set to %s\n", bn, community);
+        
+        break;
+
+      case 'H':
+        hostname = strdup(optarg);
+
+        if(verbose)
+          printf("%s: Hostname set to %s\n", bn, hostname);
+
+        break;
+
+      case 'v':
+        verbose = 1;
+        printf("%s: Verbose mode activated\n", bn);
+        break;
+    }
+  }
+
+  if(!hostname || !community)
+  {
+    printf("%s: Hostname or Community missing!\n", bn);
+    print_help();
+    exit(STATE_UNKNOWN);
+  }
+
+  ret = report_load();
+
+  if(verbose)
+    printf("%s: Returning %d\n", bn, ret);
+
+  exit(ret);
+}
+
+static int report_load()
+{
+  int cnt;
+
+  long *errors;
+  void *pnt;
+  int i;
+  int gotErrors = 0;
+  char **errormsg = NULL;
+
+  
+  if((cnt = fetch_table(LOAD_INDEX_MIB, null_callback, NULL, 0)) < 0)
+  {
+    printf("%s: Could not fetch mem index\n", bn);
+    return STATE_UNKNOWN;
+  }
+
+  if(!cnt)  // not configured
+  {
+    printf("%s: Not configure.\n", bn);
+    return STATE_WARNING;
+  }
+  
+
+  if(!(errors  = calloc(sizeof(long), cnt)))
+  {
+    printf("%s: Could not allocate memory for information\n", bn);
+    return STATE_CRITICAL;
+  }
+
+  pnt = errors;
+  if(fetch_table(LOAD_ERRORFLAG_MIB, integer_callback, pnt, cnt) < 0)
+  {
+    printf("%s: Could not fetch error list!\n", bn);
+    return STATE_UNKNOWN;
+  }
+
+  for(i=0; i<cnt; i++)
+  {
+    if(verbose)
+      printf("%s: Got Flag %ld for %d\n", bn, errors[i], i);
+
+    if(errors[i])
+    {
+      gotErrors = 1;
+      break;
+    }
+  }
+
+  errormsg = calloc(sizeof(char **), cnt);
+  if(!errormsg)
+  {
+    printf("%s: Could not allocate memory for error information\n", bn);
+    return STATE_CRITICAL;
+  }
+
+  pnt = errormsg;
+
+  if(fetch_table(LOAD_ERRORMSG_MIB, string_callback, pnt, cnt) < 0)
+  {
+    printf("%s: Could not fetch error messages\n", bn);
+    return STATE_CRITICAL;
+  }
+
+  for(i=0; i < cnt; i++)
+  {
+    if(errors[i])
+      printf("%s%s", errormsg[i], i == cnt - 1 ? "\n" : ", ");
+  }
+
+  if(gotErrors == 0)
+  {
+	printf("Checked load for %d entries.\n", cnt);
+    return STATE_OK;
+  }
+  
+  return STATE_CRITICAL;
+}
